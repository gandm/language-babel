'use strict';

/*global atom*/
const crypto = require('crypto');
const fs = require('fs');
const path = require('path');
const CompositeDisposable = require('atom').CompositeDisposable;

// This Class is repsonsible for creating a new Tagged Template grammar
// on detection of a changed Tagged Template Configuration in the package settings
module.exports = class CreateTtlGrammar {

  constructor() {
    let observeConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    this.disposable = new CompositeDisposable();
    this.configChangedTimer = null;
    this.TTL_GRAMMAR_NAME = 'language-babel-extension';
    this.TTL_SCOPENAME = `languagebabel.ttlextension`;

    if (observeConfig) {
      // look for changes in tagged template handlers
      this.disposable.add(atom.config.observe('language-babel.taggedTemplateGrammar', this.observeTtlConfig.bind(this, 10000)));
    }
  }

  destroy() {
    this.disposable.dispose();
  }

  // add new grammars to registry
  addGrammars(filename) {
    return new Promise((resolve, reject) => {
      atom.grammars.loadGrammar(filename, err => {
        if (err) {
          reject(new Error(`Unable to add Grammar to registry\n${filename}`));
        } else resolve();
      });
    });
  }

  // Check if the grammar exists under this SHA256 file name
  // If not then remove all ttl grammars and create a new one
  // This returns a Promise that resolves  with a ttl filename
  // if a new grammar was created or rejects if a problem.
  createGrammar(_ref) {
    let ttlFilename = _ref.ttlFilename,
        ttlFilenameAbsolute = _ref.ttlFilenameAbsolute,
        grammarText = _ref.grammarText;

    return new Promise((resolve, reject) => {
      this.doesGrammarFileExist(ttlFilename).then(ifFileExists => {
        if (ifFileExists) {
          resolve();
        } else {
          this.removeGrammars();
          this.removeTtlLanguageFiles().then(() => this.createGrammarFile(ttlFilenameAbsolute, grammarText)).then(() => this.addGrammars(ttlFilenameAbsolute)).then(() => {
            atom.notifications.addInfo('language-babel', { detail: `Grammar created at \n${ttlFilenameAbsolute}`, dismissable: true });
            resolve(ttlFilename);
          }).catch(err => {
            atom.notifications.addWarning('language-babel', { detail: `${err.message}`, dismissable: true });
            reject(err);
          });
        }
      });
    });
  }

  // write the ttl grammar file for this config
  createGrammarFile(filename, text) {
    return new Promise((resolve, reject) => {
      fs.writeFile(filename, text, err => {
        if (err) reject(new Error(err));else resolve();
      });
    });
  }

  // create a Grammar file's JSON text
  createGrammarText() {
    return `{
  "name": "${this.TTL_GRAMMAR_NAME}",
  "comment": "Auto generated Tag Extensions for language-babel",
  "comment": "Please do not edit this file directly",
  "scopeName": "${this.TTL_SCOPENAME}",
  "fileTypes": [],
  "patterns": [
    ${this.getTtlConfig().map(ttlString => this.createGrammarPatterns(ttlString))}
  ]
}`;
  }

  // Create a grammar's pattern derived from a the tagged template string
  // in the form matchString:includeScope
  createGrammarPatterns(ttlString) {
    let lastColonIndex = ttlString.lastIndexOf(':');
    let matchString = ttlString.substring(0, lastColonIndex);
    let includeScope = ttlString.substring(lastColonIndex + 1);
    const isValidIncludeScope = /^([a-zA-Z]\w*\.?)*(\w#([a-zA-Z]\w*\.?)*)?\w$/.test(includeScope);
    const isQuotedMatchString = /^\".*\"$/.test(matchString);

    if (matchString.length < 1 || !isValidIncludeScope) {
      throw new Error(`Error in the Tagged Template Grammar String ${ttlString}`);
    }

    if (isQuotedMatchString) {
      // Found a possible regexp in the form "regex" so strip the "
      matchString = matchString.substring(1, matchString.length - 1);
      try {
        this.onigurumaCheck(matchString);
        matchString = matchString.replace(/\\/g, "\\\\"); // \ to \\
        matchString = matchString.replace(/\\\\["]/g, "\\\\\\\""); // \\" to \\
      } catch (err) {
        throw new Error(`You entered an badly formed RegExp in the Tagged Template Grammar settings.\n${matchString}\n${err}`);
      }
    } else if (/"/g.test(matchString)) {
      throw new Error(`Bad literal string in the Tagged Template Grammar settings.\n${matchString}`);
    } else {
      // User entered a literal string which may contain chars that a special inside a regex.
      // Escape any special chars e.g. '/** @html */' -> '\/\*\* @html \*\/'
      // The string stored by Atom in the config has the \\ already escaped.
      const escapeStringRegExp = /[|{}()[\]^$+*?.]/g;
      const preEscapedSlash = /\\/g;
      matchString = matchString.replace(preEscapedSlash, '\\\\\\\\');
      matchString = matchString.replace(escapeStringRegExp, '\\\\$&');
    }

    return `{
      "contentName": "${includeScope.match(/^[^#]*/)[0]}",
      "begin": "\\\\s*+(${matchString})\\\\s*(\`)",
      "beginCaptures": {
        "1": { "name": "entity.name.tag.js" },
        "2": { "name": "punctuation.definition.quasi.begin.js" }
      },
      "end": "\\\\s*(?<=[^\\\\\\\\]\\\\\\\\\\\\\\\\|[^\\\\\\\\]|^\\\\\\\\\\\\\\\\|^)((\`))",
      "endCaptures": {
        "1": { "name": "punctuation.definition.quasi.end.js" }
      },
      "patterns": [
        { "include": "source.js.jsx#literal-quasi-embedded" },
        { "include": "${includeScope}" }
      ]
    }`;
  }

  // checks a ttl grammar filename exists
  // returns a Promise that resolves to true if ttlFileName exists
  doesGrammarFileExist(ttlFilename) {
    return new Promise(resolve => {
      fs.access(this.makeTtlGrammarFilenameAbsoulute(ttlFilename), (fs.constants || fs).R_OK, err => {
        err ? resolve(false) : resolve(true);
      });
    });
  }

  // get full path to the language-babel grammar file dir
  getGrammarPath() {
    return path.normalize(path.resolve(atom.packages.loadedPackages['language-babel'].path, './grammars'));
  }

  // get an array of all language-babel grammar files
  getGrammarFiles() {
    return new Promise((resolve, reject) => {
      fs.readdir(this.getGrammarPath(), (err, data) => {
        if (err) reject(new Error(err));else {
          resolve(data);
        }
      });
    });
  }

  // read configurations for tagged templates
  getTtlConfig() {
    return atom.config.get('language-babel').taggedTemplateGrammar;
  }

  // get an array of grammar tagged template extension filenames
  getTtlGrammarFiles() {
    return this.getGrammarFiles().then(dirFiles => dirFiles.filter(function (filename) {
      return (/^ttl-/.test(filename)
      );
    }));
  }

  // generate a SHA256 for some text
  generateTtlSHA256(stringToHash) {
    let hash = crypto.createHash('sha256');
    hash.update(stringToHash);
    return hash.digest('hex');
  }

  // tagged template filename
  makeTtlGrammarFilename(hashString) {
    return `ttl-${hashString}.json`;
  }

  // get a fully qualified filename
  makeTtlGrammarFilenameAbsoulute(ttlFilename) {
    return path.resolve(this.getGrammarPath(), ttlFilename);
  }

  // observe changes in the taggedTemplateGrammar config which take place
  // because observed config changes are fired as a user types them inside
  // settings we need to delay processing the array strings, until last char
  // entered was setTimeout seconds ago. parse tagged template configuration
  // and then create grammar and generate a SHA256 hash from the grammar
  observeTtlConfig(timeout) {
    if (this.configChangedTimer) clearTimeout(this.configChangedTimer);
    this.configChangedTimer = setTimeout(() => {
      try {
        const grammarText = this.createGrammarText();
        const hash = this.generateTtlSHA256(grammarText);
        const ttlFilename = this.makeTtlGrammarFilename(hash);
        const ttlFilenameAbsolute = this.makeTtlGrammarFilenameAbsoulute(ttlFilename);
        this.createGrammar({ ttlFilename, ttlFilenameAbsolute, grammarText });
      } catch (err) {
        atom.notifications.addWarning('language-babel', { detail: `${err.message}`, dismissable: true });
      }
    }, timeout);
  }

  // validate a regex with a Oniguruma. This will throw if it fails the checks
  // This will return true if the check passes or false if no oniguruma was found
  onigurumaCheck(regex) {
    let isRegexValid = false;
    // We need to call oniguruma's constructor via this convoluted method as I can't include
    // the github/atom/node-oniguruma package as npm on Windows get node-gyp errors unless a
    // user has installed a compiler. Find Atom's Oniguruma and call the constructor.
    if (typeof atom.grammars.grammars === "object") {
      atom.grammars.grammars.every(obj => {
        if (obj.name === "Babel ES6 JavaScript") {
          let ref, ref1, ref2;
          if ((ref = obj.firstLineRegex) != null) {
            if ((ref1 = ref.scanner) != null) {
              if ((ref2 = ref1.__proto__) != null) {
                if (typeof ref2.constructor === "function") {
                  // now call new obj.firstLineRegex.scanner.__proto__.constructor([onigString]);
                  // to validate the regex
                  new ref2.constructor([regex]);
                  isRegexValid = true;
                }
              }
            }
          }
          return false;
        } else return true;
      });
    }
    return isRegexValid;
  }

  // Remove grammars before upodating
  removeGrammars() {
    atom.grammars.removeGrammarForScopeName(this.TTL_SCOPENAME);
  }

  // remove all language files in tagged template GrammarFiles array
  removeTtlLanguageFiles() {
    return this.getTtlGrammarFiles().then(ttlGrammarFiles => {
      for (let ttlGrammarFilename of ttlGrammarFiles) {
        let ttlGrammarFileAbsoulte = this.makeTtlGrammarFilenameAbsoulute(ttlGrammarFilename);
        fs.unlink(ttlGrammarFileAbsoulte);
      }
    });
  }
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNyZWF0ZS10dGwtZ3JhbW1hci5qcyJdLCJuYW1lcyI6WyJjcnlwdG8iLCJyZXF1aXJlIiwiZnMiLCJwYXRoIiwiQ29tcG9zaXRlRGlzcG9zYWJsZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJDcmVhdGVUdGxHcmFtbWFyIiwiY29uc3RydWN0b3IiLCJvYnNlcnZlQ29uZmlnIiwiZGlzcG9zYWJsZSIsImNvbmZpZ0NoYW5nZWRUaW1lciIsIlRUTF9HUkFNTUFSX05BTUUiLCJUVExfU0NPUEVOQU1FIiwiYWRkIiwiYXRvbSIsImNvbmZpZyIsIm9ic2VydmUiLCJvYnNlcnZlVHRsQ29uZmlnIiwiYmluZCIsImRlc3Ryb3kiLCJkaXNwb3NlIiwiYWRkR3JhbW1hcnMiLCJmaWxlbmFtZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZ3JhbW1hcnMiLCJsb2FkR3JhbW1hciIsImVyciIsIkVycm9yIiwiY3JlYXRlR3JhbW1hciIsInR0bEZpbGVuYW1lIiwidHRsRmlsZW5hbWVBYnNvbHV0ZSIsImdyYW1tYXJUZXh0IiwiZG9lc0dyYW1tYXJGaWxlRXhpc3QiLCJ0aGVuIiwiaWZGaWxlRXhpc3RzIiwicmVtb3ZlR3JhbW1hcnMiLCJyZW1vdmVUdGxMYW5ndWFnZUZpbGVzIiwiY3JlYXRlR3JhbW1hckZpbGUiLCJub3RpZmljYXRpb25zIiwiYWRkSW5mbyIsImRldGFpbCIsImRpc21pc3NhYmxlIiwiY2F0Y2giLCJhZGRXYXJuaW5nIiwibWVzc2FnZSIsInRleHQiLCJ3cml0ZUZpbGUiLCJjcmVhdGVHcmFtbWFyVGV4dCIsImdldFR0bENvbmZpZyIsIm1hcCIsInR0bFN0cmluZyIsImNyZWF0ZUdyYW1tYXJQYXR0ZXJucyIsImxhc3RDb2xvbkluZGV4IiwibGFzdEluZGV4T2YiLCJtYXRjaFN0cmluZyIsInN1YnN0cmluZyIsImluY2x1ZGVTY29wZSIsImlzVmFsaWRJbmNsdWRlU2NvcGUiLCJ0ZXN0IiwiaXNRdW90ZWRNYXRjaFN0cmluZyIsImxlbmd0aCIsIm9uaWd1cnVtYUNoZWNrIiwicmVwbGFjZSIsImVzY2FwZVN0cmluZ1JlZ0V4cCIsInByZUVzY2FwZWRTbGFzaCIsIm1hdGNoIiwiYWNjZXNzIiwibWFrZVR0bEdyYW1tYXJGaWxlbmFtZUFic291bHV0ZSIsImNvbnN0YW50cyIsIlJfT0siLCJnZXRHcmFtbWFyUGF0aCIsIm5vcm1hbGl6ZSIsInBhY2thZ2VzIiwibG9hZGVkUGFja2FnZXMiLCJnZXRHcmFtbWFyRmlsZXMiLCJyZWFkZGlyIiwiZGF0YSIsImdldCIsInRhZ2dlZFRlbXBsYXRlR3JhbW1hciIsImdldFR0bEdyYW1tYXJGaWxlcyIsImRpckZpbGVzIiwiZmlsdGVyIiwiZ2VuZXJhdGVUdGxTSEEyNTYiLCJzdHJpbmdUb0hhc2giLCJoYXNoIiwiY3JlYXRlSGFzaCIsInVwZGF0ZSIsImRpZ2VzdCIsIm1ha2VUdGxHcmFtbWFyRmlsZW5hbWUiLCJoYXNoU3RyaW5nIiwidGltZW91dCIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJyZWdleCIsImlzUmVnZXhWYWxpZCIsImV2ZXJ5Iiwib2JqIiwibmFtZSIsInJlZiIsInJlZjEiLCJyZWYyIiwiZmlyc3RMaW5lUmVnZXgiLCJzY2FubmVyIiwiX19wcm90b19fIiwicmVtb3ZlR3JhbW1hckZvclNjb3BlTmFtZSIsInR0bEdyYW1tYXJGaWxlcyIsInR0bEdyYW1tYXJGaWxlbmFtZSIsInR0bEdyYW1tYXJGaWxlQWJzb3VsdGUiLCJ1bmxpbmsiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQSxNQUFNQSxTQUFTQyxRQUFRLFFBQVIsQ0FBZjtBQUNBLE1BQU1DLEtBQUtELFFBQVEsSUFBUixDQUFYO0FBQ0EsTUFBTUUsT0FBT0YsUUFBUSxNQUFSLENBQWI7QUFDQSxNQUFNRyxzQkFBc0JILFFBQVEsTUFBUixFQUFnQkcsbUJBQTVDOztBQUVBO0FBQ0E7QUFDQUMsT0FBT0MsT0FBUCxHQUNBLE1BQU1DLGdCQUFOLENBQXVCOztBQU9yQkMsZ0JBQW1DO0FBQUEsUUFBdkJDLGFBQXVCLHVFQUFQ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QUNBLHNCQUFJK0YsS0FBSy9GLFdBQVQsQ0FBcUIsQ0FBQ3dGLEtBQUQsQ0FBckI7QUFDQUMsaUNBQWUsSUFBZjtBQUNEO0FBQ0Y7QUFDRjtBQUNGO0FBQ0QsaUJBQU8sS0FBUDtBQUNELFNBZkQsTUFnQkssT0FBTyxJQUFQO0FBQ04sT0FsQkQ7QUFtQkQ7QUFDRCxXQUFPQSxZQUFQO0FBQ0Q7O0FBRUQ7QUFDQTNELG1CQUFpQjtBQUNmdkIsU0FBS1ksUUFBTCxDQUFjZ0YseUJBQWQsQ0FBd0MsS0FBSzlGLGFBQTdDO0FBQ0Q7O0FBRUQ7QUFDQTBCLDJCQUF5QjtBQUN2QixXQUFPLEtBQUsyQyxrQkFBTCxHQUEwQjlDLElBQTFCLENBQWdDd0UsZUFBRCxJQUFxQjtBQUN6RCxXQUFLLElBQUlDLGtCQUFULElBQStCRCxlQUEvQixFQUFnRDtBQUM5QyxZQUFJRSx5QkFBeUIsS0FBS3hDLCtCQUFMLENBQXFDdUMsa0JBQXJDLENBQTdCO0FBQ0EzRyxXQUFHNkcsTUFBSCxDQUFVRCxzQkFBVjtBQUNEO0FBQ0YsS0FMTSxDQUFQO0FBT0Q7QUF6UW9CLENBRHZCIiwiZmlsZSI6ImNyZWF0ZS10dGwtZ3JhbW1hci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qZ2xvYmFsIGF0b20qL1xyXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcclxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xyXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xyXG5jb25zdCBDb21wb3NpdGVEaXNwb3NhYmxlID0gcmVxdWlyZSgnYXRvbScpLkNvbXBvc2l0ZURpc3Bvc2FibGU7XHJcblxyXG4vLyBUaGlzIENsYXNzIGlzIHJlcHNvbnNpYmxlIGZvciBjcmVhdGluZyBhIG5ldyBUYWdnZWQgVGVtcGxhdGUgZ3JhbW1hclxyXG4vLyBvbiBkZXRlY3Rpb24gb2YgYSBjaGFuZ2VkIFRhZ2dlZCBUZW1wbGF0ZSBDb25maWd1cmF0aW9uIGluIHRoZSBwYWNrYWdlIHNldHRpbmdzXHJcbm1vZHVsZS5leHBvcnRzID1cclxuY2xhc3MgQ3JlYXRlVHRsR3JhbW1hciB7XHJcblxyXG4gIGRpc3Bvc2FibGUgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpO1xyXG4gIGNvbmZpZ0NoYW5nZWRUaW1lcj0gbnVsbDtcclxuICBUVExfR1JBTU1BUl9OQU1FID0gJ2xhbmd1YWdlLWJhYmVsLWV4dGVuc2lvbic7XHJcbiAgVFRMX1NDT1BFTkFNRSA9IGBsYW5ndWFnZWJhYmVsLnR0bGV4dGVuc2lvbmA7XHJcblxyXG4gIGNvbnN0cnVjdG9yKG9ic2VydmVDb25maWcgPSBmYWxzZSkge1xyXG4gICAgaWYgKG9ic2VydmVDb25maWcpICAge1xyXG4gICAgICAvLyBsb29rIGZvciBjaGFuZ2VzIGluIHRhZ2dlZCB0ZW1wbGF0ZSBoYW5kbGVyc1xyXG4gICAgICB0aGlzLmRpc3Bvc2FibGUuYWRkKGF0b20uY29uZmlnLm9ic2VydmUoJ2xhbmd1YWdlLWJhYmVsLnRhZ2dlZFRlbXBsYXRlR3JhbW1hcicsIHRoaXMub2JzZXJ2ZVR0bENvbmZpZy5iaW5kKHRoaXMsIDEwMDAwKSkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHRoaXMuZGlzcG9zYWJsZS5kaXNwb3NlKCk7XHJcbiAgfVxyXG5cclxuICAvLyBhZGQgbmV3IGdyYW1tYXJzIHRvIHJlZ2lzdHJ5XHJcbiAgYWRkR3JhbW1hcnMoZmlsZW5hbWUpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGF0b20uZ3JhbW1hcnMubG9hZEdyYW1tYXIoZmlsZW5hbWUsIChlcnIpID0+IHtcclxuICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBVbmFibGUgdG8gYWRkIEdyYW1tYXIgdG8gcmVnaXN0cnlcXG4ke2ZpbGVuYW1lfWApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSByZXNvbHZlKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gIH1cclxuXHJcbiAgLy8gQ2hlY2sgaWYgdGhlIGdyYW1tYXIgZXhpc3RzIHVuZGVyIHRoaXMgU0hBMjU2IGZpbGUgbmFtZVxyXG4gIC8vIElmIG5vdCB0aGVuIHJlbW92ZSBhbGwgdHRsIGdyYW1tYXJzIGFuZCBjcmVhdGUgYSBuZXcgb25lXHJcbiAgLy8gVGhpcyByZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzICB3aXRoIGEgdHRsIGZpbGVuYW1lXHJcbiAgLy8gaWYgYSBuZXcgZ3JhbW1hciB3YXMgY3JlYXRlZCBvciByZWplY3RzIGlmIGEgcHJvYmxlbS5cclxuICBjcmVhdGVHcmFtbWFyKHt0dGxGaWxlbmFtZSwgdHRsRmlsZW5hbWVBYnNvbHV0ZSwgZ3JhbW1hclRleHR9KSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICB0aGlzLmRvZXNHcmFtbWFyRmlsZUV4aXN0KHR0bEZpbGVuYW1lKVxyXG4gICAgICAgIC50aGVuKChpZkZpbGVFeGlzdHMpID0+IHtcclxuICAgICAgICAgIGlmIChpZkZpbGVFeGlzdHMpIHtcclxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlR3JhbW1hcnMoKTtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVUdGxMYW5ndWFnZUZpbGVzKClcclxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5jcmVhdGVHcmFtbWFyRmlsZSh0dGxGaWxlbmFtZUFic29sdXRlLCBncmFtbWFyVGV4dCkpXHJcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMuYWRkR3JhbW1hcnModHRsRmlsZW5hbWVBYnNvbHV0ZSkpXHJcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICBhdG9tLm5vdGlmaWNhdGlvbnMuYWRkSW5mbygnbGFuZ3VhZ2UtYmFiZWwnLCB7ZGV0YWlsOiBgR3JhbW1hciBjcmVhdGVkIGF0IFxcbiR7dHRsRmlsZW5hbWVBYnNvbHV0ZX1gLGRpc21pc3NhYmxlOiB0cnVlfSk7XHJcbiAgICAgICAgICAgICAgcmVzb2x2ZSh0dGxGaWxlbmFtZSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgYXRvbS5ub3RpZmljYXRpb25zLmFkZFdhcm5pbmcoJ2xhbmd1YWdlLWJhYmVsJywge2RldGFpbDogYCR7ZXJyLm1lc3NhZ2V9YCxkaXNtaXNzYWJsZTogdHJ1ZX0pO1xyXG4gICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gd3JpdGUgdGhlIHR0bCBncmFtbWFyIGZpbGUgZm9yIHRoaXMgY29uZmlnXHJcbiAgY3JlYXRlR3JhbW1hckZpbGUoZmlsZW5hbWUsdGV4dCkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgZnMud3JpdGVGaWxlKGZpbGVuYW1lLCB0ZXh0LCAoZXJyKSA9PiB7XHJcbiAgICAgICAgaWYgKGVycikgcmVqZWN0KG5ldyBFcnJvcihlcnIpKTtcclxuICAgICAgICBlbHNlIHJlc29sdmUoKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIGNyZWF0ZSBhIEdyYW1tYXIgZmlsZSdzIEpTT04gdGV4dFxyXG4gIGNyZWF0ZUdyYW1tYXJUZXh0KCkge1xyXG4gICAgcmV0dXJuIGB7XHJcbiAgXCJuYW1lXCI6IFwiJHt0aGlzLlRUTF9HUkFNTUFSX05BTUV9XCIsXHJcbiAgXCJjb21tZW50XCI6IFwiQXV0byBnZW5lcmF0ZWQgVGFnIEV4dGVuc2lvbnMgZm9yIGxhbmd1YWdlLWJhYmVsXCIsXHJcbiAgXCJjb21tZW50XCI6IFwiUGxlYXNlIGRvIG5vdCBlZGl0IHRoaXMgZmlsZSBkaXJlY3RseVwiLFxyXG4gIFwic2NvcGVOYW1lXCI6IFwiJHt0aGlzLlRUTF9TQ09QRU5BTUV9XCIsXHJcbiAgXCJmaWxlVHlwZXNcIjogW10sXHJcbiAgXCJwYXR0ZXJuc1wiOiBbXHJcbiAgICAke3RoaXMuZ2V0VHRsQ29uZmlnKCkubWFwKCh0dGxTdHJpbmcpID0+ICh0aGlzLmNyZWF0ZUdyYW1tYXJQYXR0ZXJucyh0dGxTdHJpbmcpKSl9XHJcbiAgXVxyXG59YDtcclxuICB9XHJcblxyXG4gIC8vIENyZWF0ZSBhIGdyYW1tYXIncyBwYXR0ZXJuIGRlcml2ZWQgZnJvbSBhIHRoZSB0YWdnZWQgdGVtcGxhdGUgc3RyaW5nXHJcbiAgLy8gaW4gdGhlIGZvcm0gbWF0Y2hTdHJpbmc6aW5jbHVkZVNjb3BlXHJcbiAgY3JlYXRlR3JhbW1hclBhdHRlcm5zKHR0bFN0cmluZykge1xyXG4gICAgbGV0IGxhc3RDb2xvbkluZGV4ID0gdHRsU3RyaW5nLmxhc3RJbmRleE9mKCc6Jyk7XHJcbiAgICBsZXQgbWF0Y2hTdHJpbmcgPSB0dGxTdHJpbmcuc3Vic3RyaW5nKDAsIGxhc3RDb2xvbkluZGV4KTtcclxuICAgIGxldCBpbmNsdWRlU2NvcGUgPSB0dGxTdHJpbmcuc3Vic3RyaW5nKGxhc3RDb2xvbkluZGV4KzEpO1xyXG4gICAgY29uc3QgaXNWYWxpZEluY2x1ZGVTY29wZSA9IC9eKFthLXpBLVpdXFx3KlxcLj8pKihcXHcjKFthLXpBLVpdXFx3KlxcLj8pKik/XFx3JC8udGVzdChpbmNsdWRlU2NvcGUpO1xyXG4gICAgY29uc3QgaXNRdW90ZWRNYXRjaFN0cmluZyA9IC9eXFxcIi4qXFxcIiQvLnRlc3QobWF0Y2hTdHJpbmcpO1xyXG5cclxuICAgIGlmIChtYXRjaFN0cmluZy5sZW5ndGggPCAxIHx8ICFpc1ZhbGlkSW5jbHVkZVNjb3BlKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgaW4gdGhlIFRhZ2dlZCBUZW1wbGF0ZSBHcmFtbWFyIFN0cmluZyAke3R0bFN0cmluZ31gKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIGlzUXVvdGVkTWF0Y2hTdHJpbmcgKSB7XHJcbiAgICAgIC8vIEZvdW5kIGEgcG9zc2libGUgcmVnZXhwIGluIHRoZSBmb3JtIFwicmVnZXhcIiBzbyBzdHJpcCB0aGUgXCJcclxuICAgICAgbWF0Y2hTdHJpbmcgPSBtYXRjaFN0cmluZy5zdWJzdHJpbmcoMSwgbWF0Y2hTdHJpbmcubGVuZ3RoIC0xKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB0aGlzLm9uaWd1cnVtYUNoZWNrKG1hdGNoU3RyaW5nKTtcclxuICAgICAgICBtYXRjaFN0cmluZyA9IG1hdGNoU3RyaW5nLnJlcGxhY2UoL1xcXFwvZyxcIlxcXFxcXFxcXCIpOyAvLyBcXCB0byBcXFxcXHJcbiAgICAgICAgbWF0Y2hTdHJpbmcgPSBtYXRjaFN0cmluZy5yZXBsYWNlKC9cXFxcXFxcXFtcIl0vZyxcIlxcXFxcXFxcXFxcXFxcXCJcIik7IC8vIFxcXFxcIiB0byBcXFxcXHJcbiAgICAgIH1cclxuICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IGVudGVyZWQgYW4gYmFkbHkgZm9ybWVkIFJlZ0V4cCBpbiB0aGUgVGFnZ2VkIFRlbXBsYXRlIEdyYW1tYXIgc2V0dGluZ3MuXFxuJHttYXRjaFN0cmluZ31cXG4ke2Vycn1gKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIC9cIi9nLnRlc3QobWF0Y2hTdHJpbmcpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQmFkIGxpdGVyYWwgc3RyaW5nIGluIHRoZSBUYWdnZWQgVGVtcGxhdGUgR3JhbW1hciBzZXR0aW5ncy5cXG4ke21hdGNoU3RyaW5nfWApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIC8vIFVzZXIgZW50ZXJlZCBhIGxpdGVyYWwgc3RyaW5nIHdoaWNoIG1heSBjb250YWluIGNoYXJzIHRoYXQgYSBzcGVjaWFsIGluc2lkZSBhIHJlZ2V4LlxyXG4gICAgICAvLyBFc2NhcGUgYW55IHNwZWNpYWwgY2hhcnMgZS5nLiAnLyoqIEBodG1sICovJyAtPiAnXFwvXFwqXFwqIEBodG1sIFxcKlxcLydcclxuICAgICAgLy8gVGhlIHN0cmluZyBzdG9yZWQgYnkgQXRvbSBpbiB0aGUgY29uZmlnIGhhcyB0aGUgXFxcXCBhbHJlYWR5IGVzY2FwZWQuXHJcbiAgICAgIGNvbnN0IGVzY2FwZVN0cmluZ1JlZ0V4cCA9IC9bfHt9KClbXFxdXiQrKj8uXS9nO1xyXG4gICAgICBjb25zdCBwcmVFc2NhcGVkU2xhc2ggPSAvXFxcXC9nO1xyXG4gICAgICBtYXRjaFN0cmluZyA9IG1hdGNoU3RyaW5nLnJlcGxhY2UocHJlRXNjYXBlZFNsYXNoLCAnXFxcXFxcXFxcXFxcXFxcXCcpO1xyXG4gICAgICBtYXRjaFN0cmluZyA9IG1hdGNoU3RyaW5nLnJlcGxhY2UoZXNjYXBlU3RyaW5nUmVnRXhwLCAnXFxcXFxcXFwkJicpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBge1xyXG4gICAgICBcImNvbnRlbnROYW1lXCI6IFwiJHtpbmNsdWRlU2NvcGUubWF0Y2goL15bXiNdKi8pWzBdfVwiLFxyXG4gICAgICBcImJlZ2luXCI6IFwiXFxcXFxcXFxzKisoJHttYXRjaFN0cmluZ30pXFxcXFxcXFxzKihcXGApXCIsXHJcbiAgICAgIFwiYmVnaW5DYXB0dXJlc1wiOiB7XHJcbiAgICAgICAgXCIxXCI6IHsgXCJuYW1lXCI6IFwiZW50aXR5Lm5hbWUudGFnLmpzXCIgfSxcclxuICAgICAgICBcIjJcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5kZWZpbml0aW9uLnF1YXNpLmJlZ2luLmpzXCIgfVxyXG4gICAgICB9LFxyXG4gICAgICBcImVuZFwiOiBcIlxcXFxcXFxccyooPzw9W15cXFxcXFxcXFxcXFxcXFxcXVxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcfFteXFxcXFxcXFxcXFxcXFxcXF18XlxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcfF4pKChcXGApKVwiLFxyXG4gICAgICBcImVuZENhcHR1cmVzXCI6IHtcclxuICAgICAgICBcIjFcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5kZWZpbml0aW9uLnF1YXNpLmVuZC5qc1wiIH1cclxuICAgICAgfSxcclxuICAgICAgXCJwYXR0ZXJuc1wiOiBbXHJcbiAgICAgICAgeyBcImluY2x1ZGVcIjogXCJzb3VyY2UuanMuanN4I2xpdGVyYWwtcXVhc2ktZW1iZWRkZWRcIiB9LFxyXG4gICAgICAgIHsgXCJpbmNsdWRlXCI6IFwiJHtpbmNsdWRlU2NvcGV9XCIgfVxyXG4gICAgICBdXHJcbiAgICB9YDtcclxuICB9XHJcblxyXG4gIC8vIGNoZWNrcyBhIHR0bCBncmFtbWFyIGZpbGVuYW1lIGV4aXN0c1xyXG4gIC8vIHJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdHJ1ZSBpZiB0dGxGaWxlTmFtZSBleGlzdHNcclxuICBkb2VzR3JhbW1hckZpbGVFeGlzdCh0dGxGaWxlbmFtZSkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgIGZzLmFjY2Vzcyh0aGlzLm1ha2VUdGxHcmFtbWFyRmlsZW5hbWVBYnNvdWx1dGUodHRsRmlsZW5hbWUpLCAoZnMuY29uc3RhbnRzIHx8IGZzKS5SX09LLCAoZXJyKSA9PiB7XHJcbiAgICAgICAgZXJyID8gcmVzb2x2ZShmYWxzZSk6IHJlc29sdmUodHJ1ZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBnZXQgZnVsbCBwYXRoIHRvIHRoZSBsYW5ndWFnZS1iYWJlbCBncmFtbWFyIGZpbGUgZGlyXHJcbiAgZ2V0R3JhbW1hclBhdGgoKSB7XHJcbiAgICByZXR1cm4gcGF0aC5ub3JtYWxpemUoXHJcbiAgICAgIHBhdGgucmVzb2x2ZShhdG9tLnBhY2thZ2VzLmxvYWRlZFBhY2thZ2VzWydsYW5ndWFnZS1iYWJlbCddLnBhdGgsICcuL2dyYW1tYXJzJylcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvLyBnZXQgYW4gYXJyYXkgb2YgYWxsIGxhbmd1YWdlLWJhYmVsIGdyYW1tYXIgZmlsZXNcclxuICBnZXRHcmFtbWFyRmlsZXMoKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUscmVqZWN0KSA9PiB7XHJcbiAgICAgIGZzLnJlYWRkaXIodGhpcy5nZXRHcmFtbWFyUGF0aCgpLChlcnIsIGRhdGEpID0+IHtcclxuICAgICAgICBpZiAoZXJyKSByZWplY3QobmV3IEVycm9yKGVycikpO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgcmVzb2x2ZShkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyByZWFkIGNvbmZpZ3VyYXRpb25zIGZvciB0YWdnZWQgdGVtcGxhdGVzXHJcbiAgZ2V0VHRsQ29uZmlnKCkge1xyXG4gICAgcmV0dXJuIGF0b20uY29uZmlnLmdldCgnbGFuZ3VhZ2UtYmFiZWwnKS50YWdnZWRUZW1wbGF0ZUdyYW1tYXI7XHJcbiAgfVxyXG5cclxuICAvLyBnZXQgYW4gYXJyYXkgb2YgZ3JhbW1hciB0YWdnZWQgdGVtcGxhdGUgZXh0ZW5zaW9uIGZpbGVuYW1lc1xyXG4gIGdldFR0bEdyYW1tYXJGaWxlcygpIHtcclxuICAgIHJldHVybiB0aGlzLmdldEdyYW1tYXJGaWxlcygpLnRoZW4oZGlyRmlsZXMgPT4gZGlyRmlsZXMuZmlsdGVyKGZ1bmN0aW9uKGZpbGVuYW1lKSB7XHJcbiAgICAgIHJldHVybiAvXnR0bC0vLnRlc3QoZmlsZW5hbWUpO1xyXG4gICAgfSkpO1xyXG4gIH1cclxuXHJcbiAgLy8gZ2VuZXJhdGUgYSBTSEEyNTYgZm9yIHNvbWUgdGV4dFxyXG4gIGdlbmVyYXRlVHRsU0hBMjU2KHN0cmluZ1RvSGFzaCkge1xyXG4gICAgbGV0IGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMjU2Jyk7XHJcbiAgICBoYXNoLnVwZGF0ZShzdHJpbmdUb0hhc2gpO1xyXG4gICAgcmV0dXJuIGhhc2guZGlnZXN0KCdoZXgnKTtcclxuICB9XHJcblxyXG4gIC8vIHRhZ2dlZCB0ZW1wbGF0ZSBmaWxlbmFtZVxyXG4gIG1ha2VUdGxHcmFtbWFyRmlsZW5hbWUoaGFzaFN0cmluZykge1xyXG4gICAgcmV0dXJuIGB0dGwtJHtoYXNoU3RyaW5nfS5qc29uYDtcclxuICB9XHJcblxyXG4gIC8vIGdldCBhIGZ1bGx5IHF1YWxpZmllZCBmaWxlbmFtZVxyXG4gIG1ha2VUdGxHcmFtbWFyRmlsZW5hbWVBYnNvdWx1dGUodHRsRmlsZW5hbWUpIHtcclxuICAgIHJldHVybiBwYXRoLnJlc29sdmUodGhpcy5nZXRHcmFtbWFyUGF0aCgpLCB0dGxGaWxlbmFtZSk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gb2JzZXJ2ZSBjaGFuZ2VzIGluIHRoZSB0YWdnZWRUZW1wbGF0ZUdyYW1tYXIgY29uZmlnIHdoaWNoIHRha2UgcGxhY2VcclxuICAvLyBiZWNhdXNlIG9ic2VydmVkIGNvbmZpZyBjaGFuZ2VzIGFyZSBmaXJlZCBhcyBhIHVzZXIgdHlwZXMgdGhlbSBpbnNpZGVcclxuICAvLyBzZXR0aW5ncyB3ZSBuZWVkIHRvIGRlbGF5IHByb2Nlc3NpbmcgdGhlIGFycmF5IHN0cmluZ3MsIHVudGlsIGxhc3QgY2hhclxyXG4gIC8vIGVudGVyZWQgd2FzIHNldFRpbWVvdXQgc2Vjb25kcyBhZ28uIHBhcnNlIHRhZ2dlZCB0ZW1wbGF0ZSBjb25maWd1cmF0aW9uXHJcbiAgLy8gYW5kIHRoZW4gY3JlYXRlIGdyYW1tYXIgYW5kIGdlbmVyYXRlIGEgU0hBMjU2IGhhc2ggZnJvbSB0aGUgZ3JhbW1hclxyXG4gIG9ic2VydmVUdGxDb25maWcodGltZW91dCkge1xyXG4gICAgaWYgKHRoaXMuY29uZmlnQ2hhbmdlZFRpbWVyKSBjbGVhclRpbWVvdXQodGhpcy5jb25maWdDaGFuZ2VkVGltZXIpO1xyXG4gICAgdGhpcy5jb25maWdDaGFuZ2VkVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBncmFtbWFyVGV4dCA9IHRoaXMuY3JlYXRlR3JhbW1hclRleHQoKTtcclxuICAgICAgICBjb25zdCBoYXNoID0gdGhpcy5nZW5lcmF0ZVR0bFNIQTI1NihncmFtbWFyVGV4dCk7XHJcbiAgICAgICAgY29uc3QgdHRsRmlsZW5hbWUgPSB0aGlzLm1ha2VUdGxHcmFtbWFyRmlsZW5hbWUoaGFzaCk7XHJcbiAgICAgICAgY29uc3QgdHRsRmlsZW5hbWVBYnNvbHV0ZSA9IHRoaXMubWFrZVR0bEdyYW1tYXJGaWxlbmFtZUFic291bHV0ZSh0dGxGaWxlbmFtZSk7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVHcmFtbWFyKHt0dGxGaWxlbmFtZSwgdHRsRmlsZW5hbWVBYnNvbHV0ZSwgZ3JhbW1hclRleHR9KTtcclxuICAgICAgfVxyXG4gICAgICBjYXRjaChlcnIpIHtcclxuICAgICAgICBhdG9tLm5vdGlmaWNhdGlvbnMuYWRkV2FybmluZygnbGFuZ3VhZ2UtYmFiZWwnLCB7ZGV0YWlsOiBgJHtlcnIubWVzc2FnZX1gLGRpc21pc3NhYmxlOiB0cnVlfSk7XHJcbiAgICAgIH1cclxuICAgIH0sIHRpbWVvdXQpO1xyXG4gIH1cclxuXHJcbiAgLy8gdmFsaWRhdGUgYSByZWdleCB3aXRoIGEgT25pZ3VydW1hLiBUaGlzIHdpbGwgdGhyb3cgaWYgaXQgZmFpbHMgdGhlIGNoZWNrc1xyXG4gIC8vIFRoaXMgd2lsbCByZXR1cm4gdHJ1ZSBpZiB0aGUgY2hlY2sgcGFzc2VzIG9yIGZhbHNlIGlmIG5vIG9uaWd1cnVtYSB3YXMgZm91bmRcclxuICBvbmlndXJ1bWFDaGVjayhyZWdleCkge1xyXG4gICAgbGV0IGlzUmVnZXhWYWxpZCA9IGZhbHNlO1xyXG4gICAgLy8gV2UgbmVlZCB0byBjYWxsIG9uaWd1cnVtYSdzIGNvbnN0cnVjdG9yIHZpYSB0aGlzIGNvbnZvbHV0ZWQgbWV0aG9kIGFzIEkgY2FuJ3QgaW5jbHVkZVxyXG4gICAgLy8gdGhlIGdpdGh1Yi9hdG9tL25vZGUtb25pZ3VydW1hIHBhY2thZ2UgYXMgbnBtIG9uIFdpbmRvd3MgZ2V0IG5vZGUtZ3lwIGVycm9ycyB1bmxlc3MgYVxyXG4gICAgLy8gdXNlciBoYXMgaW5zdGFsbGVkIGEgY29tcGlsZXIuIEZpbmQgQXRvbSdzIE9uaWd1cnVtYSBhbmQgY2FsbCB0aGUgY29uc3RydWN0b3IuXHJcbiAgICBpZiAodHlwZW9mIGF0b20uZ3JhbW1hcnMuZ3JhbW1hcnMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgYXRvbS5ncmFtbWFycy5ncmFtbWFycy5ldmVyeSgob2JqKSA9PiB7XHJcbiAgICAgICAgaWYgKG9iai5uYW1lID09PSBcIkJhYmVsIEVTNiBKYXZhU2NyaXB0XCIpIHtcclxuICAgICAgICAgIGxldCByZWYsIHJlZjEsIHJlZjI7XHJcbiAgICAgICAgICBpZiAoKHJlZiA9IG9iai5maXJzdExpbmVSZWdleCkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAoKHJlZjEgPSByZWYuc2Nhbm5lcikgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgIGlmICgocmVmMiA9IHJlZjEuX19wcm90b19fKSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlZjIuY29uc3RydWN0b3IgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgICAvLyBub3cgY2FsbCBuZXcgb2JqLmZpcnN0TGluZVJlZ2V4LnNjYW5uZXIuX19wcm90b19fLmNvbnN0cnVjdG9yKFtvbmlnU3RyaW5nXSk7XHJcbiAgICAgICAgICAgICAgICAgIC8vIHRvIHZhbGlkYXRlIHRoZSByZWdleFxyXG4gICAgICAgICAgICAgICAgICBuZXcgcmVmMi5jb25zdHJ1Y3RvcihbcmVnZXhdKTtcclxuICAgICAgICAgICAgICAgICAgaXNSZWdleFZhbGlkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSByZXR1cm4gdHJ1ZTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNSZWdleFZhbGlkO1xyXG4gIH1cclxuXHJcbiAgLy8gUmVtb3ZlIGdyYW1tYXJzIGJlZm9yZSB1cG9kYXRpbmdcclxuICByZW1vdmVHcmFtbWFycygpIHtcclxuICAgIGF0b20uZ3JhbW1hcnMucmVtb3ZlR3JhbW1hckZvclNjb3BlTmFtZSh0aGlzLlRUTF9TQ09QRU5BTUUpO1xyXG4gIH1cclxuXHJcbiAgLy8gcmVtb3ZlIGFsbCBsYW5ndWFnZSBmaWxlcyBpbiB0YWdnZWQgdGVtcGxhdGUgR3JhbW1hckZpbGVzIGFycmF5XHJcbiAgcmVtb3ZlVHRsTGFuZ3VhZ2VGaWxlcygpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR0bEdyYW1tYXJGaWxlcygpLnRoZW4oKHR0bEdyYW1tYXJGaWxlcykgPT4ge1xyXG4gICAgICBmb3IgKGxldCB0dGxHcmFtbWFyRmlsZW5hbWUgb2YgdHRsR3JhbW1hckZpbGVzKSB7XHJcbiAgICAgICAgbGV0IHR0bEdyYW1tYXJGaWxlQWJzb3VsdGUgPSB0aGlzLm1ha2VUdGxHcmFtbWFyRmlsZW5hbWVBYnNvdWx1dGUodHRsR3JhbW1hckZpbGVuYW1lKTtcclxuICAgICAgICBmcy51bmxpbmsodHRsR3JhbW1hckZpbGVBYnNvdWx0ZSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICB9XHJcbn07XHJcbiJdfQ==